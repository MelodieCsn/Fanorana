
public class Terrain {
	TableauPion T = new TableauPion();
	
	public void initPlateau(TableauPion T){//méthode qui remplit l'arraylist avec les Pions de début de partie
		//on commence par remplir les deux premières lignes de pions blancs
		int x = 0;
		
		while (x<9){
			T.ajoutPion(new Pion(x,0,false, false));
			x++;
		}
		int x1=0;
		while (x1<9){
			T.ajoutPion(new Pion(x1,1,false,false));
			x1++;
		}
		//on remplit les deux dernières lignes de pions noirs
		int x2=0;
		while (x2<9){
			T.ajoutPion(new Pion(x2,3,true,false));
			x2++;
		}
		int x3=0;
		while (x3<9){
			T.ajoutPion(new Pion(x3,4,true,false));
			x3++;
		}
		//On remplit 'manuellement' la ligne du milieu
		T.ajoutPion(new Pion(0,2,false,false));
		T.ajoutPion(new Pion(1,2,true,false));
		T.ajoutPion(new Pion(2,2,false,false));
		T.ajoutPion(new Pion(3,2,true,false));
		T.ajoutPion(new Pion(5,2,false,false));
		T.ajoutPion(new Pion(6,2,true,false));
		T.ajoutPion(new Pion(7,2,false,false));
		T.ajoutPion(new Pion(8,2,true,false));
		
	}
	
	public boolean diago (Pion p){
		return p.getX() % 2 == p.getY() % 2;
	}
	public boolean pionPresent(int x,int y,TableauPion T){
		boolean res;
		for(int i=0; i < 44; i++){
			if((x==T.T.get(i).getX()) && (y==T.T.get(i).getY())){
				res = true;
			}
			else{
				res=false;
			}
		}
		return res;
	}
	public boolean pionOpposePresent(int x, int y, Pion p, TableauPion T){ //x et y sont les coordonnées où on pourrait avoir un pion à percuter ou à aspirer
		
		return pionPresent(x,y,T) && (T.getPion(x,y).getCouleur()  !=   !p.getCouleur());
	}	//On vérifie qu'il y a un pion à cet emplacement et qu'il est de couleur opposée à celle du pion qu'on a déplacé
		
	
	boolean peutBouger(int x,int y, Pion p){ //on suppose que l'utilisateur nous a donné le pion a déplacer et les coordonnées où il souhaite le déplacer grâce à l'interface graphique
 		if(p.getX()%2 == p.getY()%2){// si peut bouger en diagonales
 			return (!(x>8 || x<0 || y<0 || y>4 || pionPresent(x,y,T)));
 		}
 		else{
 			return (!(x>8 || x<0 || y<0 || y>4 || pionPresent(x,y,T) || (x==p.getX()+1 && y==p.getY()+1) || (x==p.getX()+1 && y==p.getY()-1) || (x==p.getX()-1 && y==p.getY()+1) || (x==p.getX()-1 && y==p.getY()-1)));
 		}  //on renvoie faux quand les coordonnées demandées sont en diagonales en + des autres contraintes
	}
			
 		
	public void deplacer(int x,int y,Pion p){
		if(peutBouger(x,y,p)){
			T.ajoutPion(new Pion(x,y,p.getCouleur(),p.getDanger()));
			T.supprPion(p.getX(),p.getY());
			
		}
		 else{
		 	System.out.println(" erreur en disant que c'est soit parce qu'il y a un pion sur la case, soit qu'on est hors terrain");
		 }
	}

	
	
	public void avancer(int x, int y, Pion p, TableauPion T){
		//on suppose que le joueur a cliqué sur le pion qu'il veut déplacer, 
		//et qu'il a cliqué sur l'endroit où il veut aller, ce qui nous donne les paramètres de la méthode
		if (peutBouger(x,y,p)){
			int valx=p.getX();//on stocke les anciennes coordonnées du pion
			int valy=p.getY();
			deplacer(x,y,p);//on déplace le pion, donc on set les coordonnées à d'autres valeurs
			int deltax=p.getX()-valx;//on calcule la distance entre les anciennes et les nouvelles coordonnées
			int deltay=p.getY()-valy;
			int val1x=p.getX();
			int val1y=p.getY(); //on stocke les nouvelles coordonnées du pion

			if(pionOpposePresent(p.getX()+deltax,p.getY()+deltay,p,T) && pionOpposePresent(valx-deltax,valy-deltay,p,T)){
				//message pour demander si on veut percuter ou aspirer puis soit percuter soit aspirer
			}
			else if (pionOpposePresent(p.getX()+deltax,p.getY()+deltay,p,T)){
				percuter(x, y, val1x, val1y, T, deltax, deltay);
			}
			else {
				aspirer (x, y, valx, valy, T, deltax, deltay);
			}
		}
		
	}

	public void aspirer(int x,int y,int valx,int valy,TableauPion T,int deltax,int deltay){
		while(valx<8 && valx>0 && valy>0 && valy<4){
			mangerPion(valx - deltax, valy - deltay, T);
			valx=valx+deltax;
			valy=valy+deltay;
		}
	}
	
	public void percuter(int x,int y,int val1x,int val1y,TableauPion T,int deltax,int deltay){
		while(val1x<8 && val1x>0 && val1y>0 && val1y<4){
			mangerPion(val1x + deltax, val1y + deltay, T);
			val1x=val1x+deltax;
			val1y=val1y+deltay;
		}
	}
	
public void mangerPion(int x, int y, TableauPion T){
		T.supprPion(x,y);
		T.setNbPions(T.getNbPions()-1);
		System.out.println("rentré dans mangerPion");
	}

public static void main(String[] args){//test pour avancer, dans le cas d'une percution
	Terrain Terr = new Terrain();
	Terr.initPlateau(Terr.T);
	{
//		System.out.println("coordonnées avant déplacement  " +Terr.T.getPion(3,4).getX()+" ; "+ Terr.T.getPion(3,4).getY());
//		System.out.println("Pion aux anciennes coordonnées ?  " +Terr.pionPresent(4,3,Terr.T));
		System.out.println("suppression du pion...");
		Terr.mangerPion(3, 4, Terr.T);
		System.out.println("Pion aux coordonnées ?  " +Terr.pionPresent(4,2,Terr.T));
//		System.out.println("déplacement et action (soit percuter soit aspirer) en cours.... ");
//		Terr.avancer(4,2,Terr.T.getPion(4,3),Terr.T);
//		System.out.println("Pion aux anciennes coordonnées ?  " +Terr.pionPresent(4,3,Terr.T));
//		System.out.println("Pion aux nouvelles coordonnées ?  " +Terr.pionPresent(4,2,Terr.T));
//		System.out.println("Pion de couleur opposée sur la ligne percutée ou aspirée ?  " +Terr.pionPresent(4,1,Terr.T));
	}
}





	
}
